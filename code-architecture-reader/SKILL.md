---
name: code-architecture-reader
description: 通用工程代码架构解读、模块边界梳理、关键调用链追踪与设计优缺点分析技能。用于需要辅助阅读项目代码并讲清架构和设计取舍的场景，例如：新接手代码库、重构前评估、技术方案复盘、代码审查中的架构层面分析、识别耦合风险/扩展性问题/测试盲区、为团队输出系统设计理解报告。适用于“理解结构与设计质量”的任务；不适用于需要真实运行验证、性能压测结论或精确生产数据归因的场景（除非用户已提供证据）。
---

# Code Architecture Reader

## 目标

阅读工程代码并输出可落地的架构分析，先讲清系统结构，再讲清设计优点、缺点、风险与改进方向。

默认用中文输出；对领域内专业名词在首次出现时添加英文注释，例如：依赖注入 (Dependency Injection, DI)、领域模型 (Domain Model)、反腐层 (Anti-Corruption Layer)。

## 适用边界

优先用于：

1. 架构理解与模块边界梳理
2. 设计优缺点与可维护性评估
3. 重构前风险识别
4. 新成员快速建立系统心智模型 (Mental Model)

不应直接用于：

1. 需要运行时验证的性能结论（无 profile/trace）
2. 需要生产流量/故障数据支撑的根因定责
3. 安全/合规/法律结论（高风险决策）

遇到这些场景时，先给“代码侧可观察结论 + 缺失证据清单”。

## 执行原则

1. 先给全局图景，再给局部细节。
2. 明确区分“事实 (Fact)”与“推断 (Inference)”。
3. 所有关键结论必须附代码证据，使用文件路径和行号引用。
4. 优点与缺点都要写，避免只列问题。
5. 优先指出高影响问题：边界不清、隐式耦合、状态分散、异常处理不一致、可测试性差、扩展性瓶颈。
6. 在上下文不足时先列假设，再继续分析，不要空泛下结论。
7. 先声明分析范围与抽样策略，再输出强结论。
8. 为关键结论标注置信度（高/中/低），尤其是推断项。

## 输出档位（按需选择）

根据用户诉求和项目规模选择档位，默认“标准版”；用户明确要求时再切换。

1. 快读版（Quick Read）
   用于快速建立结构认知。输出：架构总览 + 模块职责 + 主要风险/优点 + 待确认项。
2. 标准版（Standard）
   用于重构前评估或评审准备。输出：总览 + 关键路径 + 优缺点 + 分级建议。
3. 深度版（Deep Dive）
   用于正式技术复盘或系统设计理解报告。输出完整模板（含抽样声明、证据索引、残余风险）。

如果用户未指定，但项目规模大且上下文有限，先给“标准版 + 后续深挖建议”。

## 分析流程（深度版）

### 1. 明确目标与范围

先识别用户要理解的是哪一层：

1. 系统整体架构 (System Architecture)
2. 某个子系统/模块架构 (Subsystem / Module Architecture)
3. 某条业务链路 (Business Flow / Request Path)
4. 某类设计机制（缓存 Cache、并发 Concurrency、插件机制 Plugin System 等）

如果用户未指定范围，先按“整体架构 + 1 条核心链路”执行。

若信息不足，优先使用 `references/scope-intake-template.md` 中的问题骨架进行范围确认。

### 2. 建立项目地图 (Project Map)

优先做快速扫描，不要一开始深挖单个文件。

建议步骤：

1. 查入口文件与启动命令（如 `main.*`、`app.*`、`server.*`、`index.*`、`package.json`、`pyproject.toml`、`go.mod`、`pom.xml`、`Cargo.toml`、`Dockerfile`、`compose`）。
2. 扫描目录结构并按职责分组（接口层 Interface/API、应用层 Application、领域层 Domain、基础设施层 Infrastructure 等）。
3. 识别配置与依赖注入装配位置（Composition Root）。
4. 识别数据边界：数据库访问、外部 API、消息队列 (Message Queue)、缓存、文件系统。
5. 识别横切关注点 (Cross-Cutting Concerns)：日志 Logging、鉴权 Authentication/Authorization、监控 Observability、错误处理 Error Handling。

大型仓库建议增加时间盒 (Timeboxing)：

1. 第一轮（5-10 分钟）：入口、目录、构建方式
2. 第二轮（10-20 分钟）：模块映射、依赖方向、关键链路候选
3. 第三轮（定向深挖）：只追踪 1-2 条链路

### 3. 抽取架构视图 (Architecture Views)

至少输出以下视图中的 3 类（根据项目类型裁剪）：

1. 模块视图 (Module View)：模块职责、边界、依赖方向。
2. 运行时视图 (Runtime View)：请求/任务执行路径、线程或协程模型、异步边界。
3. 数据视图 (Data Flow View)：数据来源、变换、落库/缓存路径、一致性策略。
4. 集成视图 (Integration View)：外部系统交互、适配器 (Adapter)、协议与失败处理。
5. 演进视图 (Evolution View)：扩展点、插件点、未来改造成本较高区域（若证据充分）。

### 4. 追踪关键路径 (Critical Path Tracing)

选择 1-2 条高价值链路进行端到端追踪。优先级：

1. 主业务路径（用户最常用功能）
2. 风险路径（事务、并发、重试、补偿、权限）
3. 性能敏感路径（高频调用、批处理、热点查询）

追踪时回答：

1. 入口在哪里？
2. 中间经过哪些层与对象？
3. 状态在何处变更？
4. 错误如何传播和处理？
5. 哪些依赖是硬耦合 (Tight Coupling)？
6. 哪些点适合扩展或替换？

### 5. 评估设计优点与缺点 (Strengths / Weaknesses)

从以下维度评估，并给出代码证据：

1. 模块内聚 (Cohesion) 与模块耦合 (Coupling)
2. 抽象层次与边界清晰度 (Abstraction / Boundary Clarity)
3. 可测试性 (Testability)
4. 可扩展性 (Extensibility)
5. 可维护性 (Maintainability)
6. 可观测性 (Observability)
7. 一致性 (Consistency)：命名、错误处理、接口约定、配置方式
8. 性能与资源效率 (Performance / Resource Efficiency)，仅在证据充分时评价

输出优点时要解释“为什么这在工程上有价值”；输出缺点时要说明“影响范围、触发条件、潜在后果”。

风险建议按优先级标注：

1. `P1` 高优先级：高影响、高概率或阻碍演进
2. `P2` 中优先级：有明确成本但可暂缓
3. `P3` 低优先级：风格或局部一致性问题（避免过度放大）

### 6. 形成改进建议 (Improvement Plan)

将建议按优先级分层：

1. 立即可做（低成本/高收益）
2. 中期改造（需要跨模块调整）
3. 长期演进（架构层面变更）

每条建议尽量包含：

1. 目标
2. 触及模块
3. 预期收益
4. 风险与回滚思路（如适用）
5. 验证方式（单元测试、集成测试、日志对比、回归检查等）

## 输出格式要求

默认输出深度版结构。优先使用 `references/report-template.md` 作为骨架；如果用户要求简版，再裁剪。

必须包含：

1. 架构总览
2. 模块职责与依赖关系
3. 至少 1 条关键路径分析
4. 设计优点（带证据）
5. 设计缺点/风险（带证据）
6. 改进建议（分优先级）
7. 不确定项与需确认问题

推荐附加：

1. 抽样范围与未覆盖区域
2. 关键结论置信度标签（高/中/低）
3. 残余风险/测试盲区（Residual Risks / Testing Gaps）

## 证据标准

1. 文件引用使用路径 + 行号。
2. 对行为的结论优先基于实际代码，不仅基于命名猜测。
3. 对运行时行为无法直接验证时，标记为推断，并说明推断依据。
4. 如果项目较大，先声明抽样范围，避免假装覆盖全量。
5. 对性能、并发、安全等高风险判断，若缺运行证据应降级为“代码层风险提示”而非确定结论。

## 常见陷阱（避免）

1. 把目录结构描述当成架构分析。
2. 只谈“分层清晰”而没有代码证据。
3. 将风格偏好误判为设计缺陷。
4. 在未追踪关键链路前就下性能结论。
5. 忽略测试代码、配置代码和组装代码，导致误判边界。
6. 在大型仓库中试图“全覆盖”导致输出空泛、证据稀薄。
7. 结论没有优先级，导致用户无法采取行动。

## 参考资源

按需读取，不要一次性加载全部内容：

1. `references/report-template.md`
   用于输出深度版报告骨架。
2. `references/analysis-checklist.md`
   用于执行前/收尾时做遗漏检查。
3. `references/scope-intake-template.md`
   用于用户未明确范围时快速确认目标、深度和约束。
